<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lunar Vision</title>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #1a2a3a;
            --secondary: #2c3e50;
            --accent: #3498db;
            --accent-light: #5dade2;
            --text: #ecf0f1;
            --text-secondary: #bdc3c7;
            --success: #2ecc71;
            --warning: #f39c12;
            --danger: #e74c3c;
            --card-bg: rgba(15, 23, 42, 0.85);
            --card-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            color: var(--text);
            background-color: var(--primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background-image: url('https://hebbkx1anhila5yf.public.blob.vercel-storage.com/8deec70cff780fe56d1365915016af45.jpg-1K2yWu0WJBCrXiVKaZir4S7Ip9qSgq.jpeg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: -1;
        }

        .app-container {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: white;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            letter-spacing: 1px;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 1rem;
            max-width: 600px;
            margin: 0 auto;
        }

        .card {
            background: var(--card-bg);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 1px solid var(--card-border);
            margin-bottom: 30px;
        }

        .card-header {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-bottom: 1px solid var(--card-border);
        }

        .card-header h2 {
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-header h2 i {
            color: var(--accent);
        }

        .card-body {
            padding: 25px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .input-group {
            position: relative;
        }

        .input-group i {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--accent);
        }

        select,
        input {
            width: 100%;
            padding: 12px 15px 12px 45px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.2);
            color: var(--text);
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        select:focus,
        input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.3);
        }

        select option {
            background-color: var(--secondary);
            color: var(--text);
        }

        button {
            width: 100%;
            padding: 14px;
            border-radius: 8px;
            border: none;
            background: var(--accent);
            color: white;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        button:hover {
            background: var(--accent-light);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .result-card {
            display: none;
        }

        .result-card.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .result-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .result-header h3 {
            font-size: 1.2rem;
            color: var(--text);
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .result-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid var(--card-border);
        }

        .result-item .label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .result-item .value {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .visibility-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.2);
        }

        .visibility-indicator i {
            font-size: 2rem;
        }

        .visibility-indicator.impossible {
            border-left: 4px solid var(--danger);
        }

        .visibility-indicator.difficult {
            border-left: 4px solid var(--warning);
        }

        .visibility-indicator.possible {
            border-left: 4px solid var(--accent);
        }

        .visibility-indicator.likely {
            border-left: 4px solid var(--success);
        }

        .visibility-text {
            flex: 1;
        }

        .visibility-text h4 {
            margin-bottom: 5px;
        }

        .visibility-text p {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .loader {
            display: none;
            width: 48px;
            height: 48px;
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .footer {
            text-align: center;
            margin-top: 30px;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .result-grid {
                grid-template-columns: 1fr;
            }

            .card-body {
                padding: 20px;
            }
        }

        /* Dark mode toggle */
        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--card-border);
            color: var(--text);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: rgba(0, 0, 0, 0.5);
        }
    </style>
</head>

<body>
    <div class="app-container">
        <div class="header">
            <h1><i class="fas fa-moon"></i> Lunar Vision</h1>
            <p>Predict moon sighting visibility with precision astronomical calculations</p>
        </div>

        <div class="card">
            <div class="card-header">
                <h2><i class="fas fa-search"></i> Moon Sighting Predictor</h2>
            </div>
            <div class="card-body">
                <div class="form-group">
                    <label for="country">Select Location</label>
                    <div class="input-group">
                        <i class="fas fa-globe-americas"></i>
                        <select id="country"></select>
                    </div>
                </div>

                <div class="form-group">
                    <label for="moonSightingDatetime">Sunset Time (Optional)</label>
                    <div class="input-group">
                        <i class="far fa-calendar-alt"></i>
                        <input type="datetime-local" id="moonSightingDatetime">
                    </div>
                </div>

                <button id="predictBtn" onclick="predictMoonSighting()">
                    <i class="fas fa-telescope"></i> Check Moon Visibility
                </button>
            </div>
        </div>

        <div class="loader" id="loader"></div>

        <div class="card result-card" id="resultCard">
            <div class="card-header">
                <h2><i class="fas fa-chart-bar"></i> Visibility Analysis</h2>
            </div>
            <div class="card-body">
                <div id="result"></div>
            </div>
        </div>

        <div class="footer">
            <p>© 2025 Lunar Vision | Astronomical Calculations & Moon Sighting Predictions</p>
        </div>
    </div>

    <script>
        // Function to set the current datetime in the input field
        function setCurrentDatetime() {
            const now = new Date();
            // Format the date as 'YYYY-MM-DDTHH:MM'
            const formattedDate = now.toISOString().slice(0, 16); // Slice to get the 'YYYY-MM-DDTHH:MM' format
            document.getElementById('moonSightingDatetime').value = formattedDate;
        }

        // Country to country code map (You can add more as needed)
        const countryCodes = {
            "ar": "Argentina",
            "au": "Australia",
            "at": "Austria",
            "by": "Belarus",
            "be": "Belgium",
            "ba": "Bosnia and Herzegovina",
            "br": "Brazil",
            "bg": "Bulgaria",
            "ca": "Canada",
            "cl": "Chile",
            "cn": "China",
            "co": "Colombia",
            "cy": "Cyprus",
            "cz": "Czech Republic",
            "dk": "Denmark",
            "do": "Dominican Republic",
            "eg": "Egypt",
            "ee": "Estonia",
            "fi": "Finland",
            "fr": "France",
            "de": "Germany",
            "gr": "Greece",
            "hu": "Hungary",
            "is": "Iceland",
            "in": "India",
            "id": "Indonesia",
            "ie": "Ireland",
            "il": "Israel",
            "it": "Italy",
            "jp": "Japan",
            "ke": "Kenya",
            "kr": "South Korea",
            "lv": "Latvia",
            "lt": "Lithuania",
            "li": "Liechtenstein",
            "lu": "Luxembourg",
            "mg": "Madagascar",
            "my": "Malaysia",
            "ml": "Mali",
            "ma": "Morocco",
            "md": "Moldova",
            "mx": "Mexico",
            "nl": "Netherlands",
            "nz": "New Zealand",
            "ng": "Nigeria",
            "no": "Norway",
            "pk": "Pakistan",
            "pe": "Peru",
            "ph": "Philippines",
            "pl": "Poland",
            "pt": "Portugal",
            "qa": "Qatar",
            "ro": "Romania",
            "ru": "Russia",
            "sa": "Saudi Arabia",
            "rs": "Serbia",
            "sg": "Singapore",
            "sk": "Slovakia",
            "si": "Slovenia",
            "za": "South Africa",
            "es": "Spain",
            "se": "Sweden",
            "ch": "Switzerland",
            "ch-fr": "Switzerland (French)",
            "ch-it": "Switzerland (Italian)",
            "tw": "Taiwan",
            "th": "Thailand",
            "tr": "Turkey",
            "ua": "Ukraine",
            "gb": "United Kingdom",
            "us": "United States",
            "uz": "Uzbekistan",
            "ve": "Venezuela"
        };

        // Dynamically generate options for the country select dropdown
        const countrySelect = document.getElementById('country');

        for (const code in countryCodes) {
            const option = document.createElement('option');
            option.value = code;
            option.textContent = countryCodes[code];

            // Set South Africa (za) as the default selected option
            if (code === "za") {
                option.selected = true;
            }

            countrySelect.appendChild(option);
        }

        async function getWeatherData(lat, lon, sightingDate) {
            try {
                const response = await fetch(`https://api.met.no/weatherapi/locationforecast/2.0/compact?lat=${lat}&lon=${lon}`, {
                    headers: { "User-Agent": "MoonSightingApp/1.0" }
                });
                const data = await response.json();

                const timeseries = data.properties.timeseries;
                if (!timeseries || timeseries.length === 0) return null;

                // Convert sightingDate to UTC string format
                const sightingTimeUTC = new Date(sightingDate).toISOString();

                // Find the closest available weather data point
                let closestWeather = timeseries.reduce((prev, curr) =>
                    Math.abs(new Date(curr.time) - new Date(sightingTimeUTC)) <
                        Math.abs(new Date(prev.time) - new Date(sightingTimeUTC)) ? curr : prev
                );

                return closestWeather?.data?.instant?.details?.cloud_area_fraction ?? null;
            } catch (error) {
                console.error("Weather API error:", error);
                return null;
            }
        }

        async function getSunsetTime(date = new Date().toISOString().split('T')[0], lat, lon) {
            try {
                const response = await fetch(`https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lon}&date=${date}&formatted=0`);
                const data = await response.json();

                if (data.status === "OK") {
                    const sunsetUtc = new Date(data.results.sunset);
                    return sunsetUtc;
                } else {
                    console.error("Error fetching sunset time:", data.status);
                    return null;
                }
            } catch (error) {
                console.error("Fetch error:", error);
                return null;
            }
        }

        // Function to get the user's current location (coordinates)
        function getUserLocation() {
            return new Promise((resolve, reject) => {
                if ("geolocation" in navigator) {
                    // Request the user's current position
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            // Successfully got the user's position
                            const { latitude, longitude } = position.coords;
                            resolve({ lat: latitude, lon: longitude });
                        },
                        (error) => {
                            // If there's an error (e.g., user denies location access)
                            reject("Error getting location: " + error.message);
                        }
                    );
                } else {
                    reject("Geolocation is not supported by this browser.");
                }
            });
        }

        async function predictMoonSighting() {
            const countryCode = document.getElementById('country').value;
            const resultDiv = document.getElementById('result');
            const sightingDatetime = document.getElementById('moonSightingDatetime').value;
            const loader = document.getElementById('loader');
            const resultCard = document.getElementById('resultCard');
            
            // Show loader, hide results
            loader.style.display = 'block';
            resultCard.classList.remove('active');
            
            // Fetch the moon data for the selected country
            try {
                const response = await fetch(`https://gh-pages-cors.haffejeeyoosuf1.workers.dev/?https://calendar-yearly.com/moon/${countryCode.toLowerCase()}/2025`);
                const html = await response.text();

                // Parse the HTML response and extract the required details
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                // Get the timezone by looking for divs with the class 'w-1/3 text-gray-600 font-bold text-right pr-4 dark:text-gray-300' and then grabbing the next div
                const timezoneElements = doc.querySelectorAll('.text-gray-600.font-bold.text-right.pr-4');
                const timezoneElement = timezoneElements[5] ? timezoneElements[5].nextElementSibling : null; // Get the 6th div's next sibling (timezone value)

                // Get the new moon date (the third element with the class "px-7 pt-1 font-semibold")
                const newMoonElements = doc.querySelectorAll('.px-7.pt-1.font-semibold');
                const newMoonElement = newMoonElements[2];  // 3rd one

                if (!newMoonElement || !timezoneElement) {
                    resultDiv.innerHTML = `
                        <div class="visibility-indicator impossible">
                            <i class="fas fa-exclamation-circle"></i>
                            <div class="visibility-text">
                                <h4>Error</h4>
                                <p>Unable to find new moon data. Please try again.</p>
                            </div>
                        </div>
                    `;
                    loader.style.display = 'none';
                    resultCard.classList.add('active');
                    return;
                }

                const { lat, lon } = await getUserLocation();

                // Extract the new moon date and timezone
                const newMoonDateString = newMoonElement.textContent.trim();
                const timezone = timezoneElement.textContent.trim();

                // Convert the new moon date (e.g., "March 29, 2025 12:58 PM") to Date object
                const newMoonDate = parseDate(newMoonDateString, timezone);
                let sightingDate = new Date(sightingDatetime);

                if (!sightingDatetime) {
                    let formattedNewMoonDate = newMoonDate.toISOString().split('T')[0];
                    sightingDate = await getSunsetTime(formattedNewMoonDate, lat, lon);

                    const offset = sightingDate.getTimezoneOffset() * 60000; // Offset in milliseconds
                    const localDate = new Date(sightingDate - offset).toISOString().slice(0, 16);
                    document.getElementById('moonSightingDatetime').value = localDate;
                }

                const epochTime = Math.floor(new Date(sightingDate).getTime() / 1000);

                // Call the Farmsense API for moon phase data
                const apiUrl = `https://gh-pages-cors.haffejeeyoosuf1.workers.dev/?https://api.farmsense.net/v1/moonphases/?d=${epochTime}`;
                const apiResponse = await fetch(apiUrl);
                const moonData = await apiResponse.json();

                if (moonData.length === 0 || moonData[0].Error) {
                    resultDiv.innerHTML = `
                        <div class="visibility-indicator impossible">
                            <i class="fas fa-exclamation-circle"></i>
                            <div class="visibility-text">
                                <h4>Error</h4>
                                <p>Error fetching moon phase data. Please try again.</p>
                            </div>
                        </div>
                    `;
                    loader.style.display = 'none';
                    resultCard.classList.add('active');
                    return;
                }

                // Get weather data (cloud cover %)
                const cloudCover = await getWeatherData(lat, lon, sightingDate);

                // Get moon data
                const moonInfo = moonData[0];
                
                // Convert moon age from days to hours
                const moonAge = (sightingDate - newMoonDate) / (1000 * 60 * 60); // Convert ms to hours

                // Convert illumination to percentage
                const illumination = moonInfo.Illumination * 100;

                // Use Angular Diameter as a secondary indicator (larger moons are easier to see)
                const angularDiameter = moonInfo.AngularDiameter;

                const sightingProbability = calculateFinalProbability(moonAge, illumination, angularDiameter);
                const sightingProbabilityPercentage = finalProbability;

                // Adjust for cloud cover if provided.
                let cloudMessage = "";
                let cloudAdjustedProbability = finalProbability;
                
                if (cloudCover !== null) {
                    if (cloudCover > 80) {
                        cloudAdjustedProbability = Math.max(finalProbability - 50, 0);
                        cloudMessage = `Unlikely in your area (~${Math.round(cloudAdjustedProbability)}%) - Cloudy Sky`;
                    } else if (cloudCover > 50) {
                        // For partly cloudy skies, reduce the final probability by 10%
                        cloudAdjustedProbability = Math.max(finalProbability - 15, 0);
                        cloudMessage = `(~${Math.round(cloudAdjustedProbability)}%) - Partly Cloudy`;
                    }
                    else if (cloudCover > 25) {
                        cloudAdjustedProbability = Math.max(finalProbability - 5, 0);
                        cloudMessage = `(~${Math.round(cloudAdjustedProbability)}%) - Mostly Clear`;
                    }
                    else {
                        cloudMessage = `(~${Math.round(cloudAdjustedProbability)}%) - Clear Skies`;
                    }
                }

                // Determine the likely start date of the new lunar month
                const likelyStartDate = sightingProbabilityPercentage > 50 ? 
                    sightingDate.toLocaleDateString() : 
                    new Date(sightingDate.getTime() + 86400000).toLocaleDateString();

                // Determine visibility class for styling
                let visibilityClass = "impossible";
                let visibilityIcon = "fa-times-circle";
                
                if (finalProbability >= 80) {
                    visibilityClass = "likely";
                    visibilityIcon = "fa-check-circle";
                } else if (finalProbability >= 60) {
                    visibilityClass = "likely";
                    visibilityIcon = "fa-check";
                } else if (finalProbability >= 40) {
                    visibilityClass = "possible";
                    visibilityIcon = "fa-question-circle";
                } else if (finalProbability >= 20) {
                    visibilityClass = "difficult";
                    visibilityIcon = "fa-exclamation-triangle";
                }

                // Display results
                resultDiv.innerHTML = `
                    <div class="result-header">
                        <h3>Moon Visibility Analysis</h3>
                    </div>
                    
                    <div class="result-grid">
                        <div class="result-item">
                            <div class="label"><i class="fas fa-calendar-day"></i> New Moon Born</div>
                            <div class="value">${newMoonDate.toLocaleString()}</div>
                        </div>
                        
                        <div class="result-item">
                            <div class="label"><i class="fas fa-hourglass-half"></i> Moon Age</div>
                            <div class="value">${moonAge.toFixed(2)} hours</div>
                        </div>
                        
                        <div class="result-item">
                            <div class="label"><i class="fas fa-adjust"></i> Illumination</div>
                            <div class="value">${illumination.toFixed(1)}%</div>
                        </div>
                        
                        <div class="result-item">
                            <div class="label"><i class="fas fa-ruler-combined"></i> Angular Diameter</div>
                            <div class="value">${angularDiameter.toFixed(2)}°</div>
                        </div>
                        
                        ${cloudCover !== null ? `
                        <div class="result-item">
                            <div class="label"><i class="fas fa-cloud"></i> Cloud Cover</div>
                            <div class="value">${cloudCover.toFixed(1)}%</div>
                        </div>
                        ` : ''}
                    </div>
                    
                    <div class="visibility-indicator ${visibilityClass}">
                        <i class="fas ${visibilityIcon}"></i>
                        <div class="visibility-text">
                            <h4>Estimated Visibility: ${sightingProbability}</h4>
                            ${cloudCover !== null ? `<p>Local Conditions: ${cloudMessage}</p>` : ''}
                        </div>
                    </div>
                    
                    <div class="visibility-indicator likely" style="margin-top: 15px;">
                        <i class="fas fa-calendar-check"></i>
                        <div class="visibility-text">
                            <h4>New Lunar Month Start Date</h4>
                            <p>${likelyStartDate} (After Sunset)</p>
                        </div>
                    </div>
                `;
                
                // Hide loader, show results
                loader.style.display = 'none';
                resultCard.classList.add('active');
                
            } catch (error) {
                resultDiv.innerHTML = `
                    <div class="visibility-indicator impossible">
                        <i class="fas fa-exclamation-circle"></i>
                        <div class="visibility-text">
                            <h4>Error</h4>
                            <p>Error fetching data. Please try again. ${error}</p>
                        </div>
                    </div>
                `;
                console.error(error);
                loader.style.display = 'none';
                resultCard.classList.add('active');
            }
        }

        // Calculate probability for moonAge with custom thresholds and linear interpolation
        function calcMoonAgeProbability(moonAge) {
            let probability, message;
            if (moonAge <= 12) {
                probability = 5;
                message = `Impossible (~${probability}%) - Too Young`;
            } else if (moonAge <= 15) {
                // Interpolate from 5% at 12 hrs to 25% at 15 hrs
                probability = 5 + ((moonAge - 12) / (15 - 12)) * (25 - 5);
                message = `Extremely Difficult (~${Math.round(probability)}%)`;
            } else if (moonAge < 18) {
                // Interpolate from 25% at 15 hrs to 50% at 18 hrs
                probability = 25 + ((moonAge - 15) / (18 - 15)) * (50 - 25);
                message = `Possible (~${Math.round(probability)}%)`;
            } else if (moonAge <= 24) {
                // Interpolate from 50% at 18 hrs to 70% at 24 hrs
                probability = 50 + ((moonAge - 18) / (24 - 18)) * (70 - 50);
                message = `Likely (~${Math.round(probability)}%)`;
            } else {
                probability = 90;
                message = `Easily Visible (~${probability}%)`;
            }
            return { probability, message };
        }

        // Calculate probability for illumination with custom thresholds (example values)
        function calcIlluminationProbability(illumination) {
            let probability, message;
            if (illumination <= 1) {
                probability = 5;
                message = `Impossible (~${probability}%)`;
            } else if (illumination <= 2) {
                // Interpolate from 5% to 20%
                probability = 5 + ((illumination - 1) / (2 - 1)) * (20 - 5);
                message = `Difficult (~${Math.round(probability)}%)`;
            } else if (illumination <= 3) {
                // Interpolate from 20% to 50%
                probability = 20 + ((illumination - 2) / (3 - 2)) * (50 - 20);
                message = `Possible (~${Math.round(probability)}%)`;
            } else if (illumination < 5) {
                // Interpolate from 50% to 70%
                probability = 50 + ((illumination - 3) / (5 - 3)) * (70 - 50);
                message = `Likely (~${Math.round(probability)}%)`;
            } else if (illumination <= 7) {
                // Interpolate from 70% to 90%
                probability = 70 + ((illumination - 5) / (7 - 5)) * (90 - 70);
                message = `Very Likely (~${Math.round(probability)}%)`;
            } else {
                probability = 90;
                message = `Easily Visible (~${probability}%)`;
            }
            return { probability, message };
        }

        // Calculate probability for angularDiameter with custom thresholds (example values)
        function calcAngularDiameterProbability(angularDiameter) {
            let probability, message;
            if (angularDiameter < 0.5) {
                probability = 5;
                message = `Impossible (~${probability}%)`;
            } else if (angularDiameter <= 0.52) {
                // Interpolate from 5% to 25%
                probability = 5 + ((angularDiameter - 0.5) / (0.52 - 0.5)) * (25 - 5);
                message = `Extremely Difficult (~${Math.round(probability)}%)`;
            } else if (angularDiameter < 0.53) {
                // Interpolate from 25% to 50%
                probability = 25 + ((angularDiameter - 0.52) / (0.53 - 0.52)) * (50 - 25);
                message = `Possible (~${Math.round(probability)}%)`;
            } else if (angularDiameter <= 0.55) {
                // Interpolate from 50% to 70%
                probability = 50 + ((angularDiameter - 0.53) / (0.55 - 0.53)) * (70 - 50);
                message = `Likely (~${Math.round(probability)}%)`;
            } else {
                probability = 90;
                message = `Easily Visible (~${probability}%)`;
            }
            return { probability, message };
        }

        let finalProbability = 0;
        // Combine the probabilities from all three parameters into a final probability.
        // Here we simply average the three probabilities. You could adjust this with weights if desired.
        function calculateFinalProbability(moonAge, illumination, angularDiameter) {
            const moon = calcMoonAgeProbability(moonAge);
            const illum = calcIlluminationProbability(illumination);
            const angDia = calcAngularDiameterProbability(angularDiameter);

            // Simple average of the three probabilities.
            finalProbability = (moon.probability + illum.probability + angDia.probability) / 3;

            // Choose a final message based on the final probability value.
            let finalMessage;
            if (finalProbability < 20) {
                finalMessage = `Impossible (~${Math.round(finalProbability)}%)`;
            } else if (finalProbability < 40) {
                finalMessage = `Extremely Difficult (~${Math.round(finalProbability)}%)`;
            } else if (finalProbability < 60) {
                finalMessage = `Possible (~${Math.round(finalProbability)}%)`;
            } else if (finalProbability < 80) {
                finalMessage = `Likely (~${Math.round(finalProbability)}%)`;
            } else {
                finalMessage = `Easily Visible (~${Math.round(finalProbability)}%)`;
            }

            return finalMessage;
        }

        // Helper function to convert a formatted string into a valid date
        function parseDate(dateString, timezone) {
            // Replace the month names with numbers (March -> 03, etc.)
            const months = {
                'January': '01', 'February': '02', 'March': '03', 'April': '04', 'May': '05', 'June': '06',
                'July': '07', 'August': '08', 'September': '09', 'October': '10', 'November': '11', 'December': '12'
            };

            const regex = /([A-Za-z]+) (\d{1,2}), (\d{4}) (\d{1,2}):(\d{2}) (AM|PM)/;
            const match = dateString.match(regex);

            if (match) {
                // Extract the parts of the date string
                const monthName = match[1];
                const day = match[2].padStart(2, '0');
                const year = match[3];
                let hour = parseInt(match[4]);
                const minute = match[5];
                const ampm = match[6];

                // Convert to 24-hour format
                if (ampm === 'PM' && hour < 12) {
                    hour += 12;
                }
                if (ampm === 'AM' && hour === 12) {
                    hour = 0;
                }

                // Format the date string as 'YYYY-MM-DDTHH:MM:SS'
                const formattedDate = `${year}-${months[monthName]}-${day}T${hour.toString().padStart(2, '0')}:${minute}:00`;

                // Create a Date object in UTC, adjusting for the timezone offset
                const date = new Date(formattedDate);

                // Use the timezone info to adjust the time (if needed)
                const timeZoneOffset = new Date().toLocaleString("en-US", { timeZone: timezone });
                const formattedDateWithTimezone = new Date(date.toLocaleString("en-US", { timeZone: timezone }));

                return formattedDateWithTimezone;
            }
            return null; // Return null if the string does not match the pattern
        }
    </script>

</body>

</html>

