<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lunar Vision</title>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&family=Playfair+Display:wght@400;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --primary: #1a2a3a;
            --secondary: #2c3e50;
            --accent: #3498db;
            --accent-light: #5dade2;
            --text: #ecf0f1;
            --text-secondary: #bdc3c7;
            --success: #2ecc71;
            --warning: #f39c12;
            --danger: #e74c3c;
            --card-bg: rgba(15, 23, 42, 0.85);
            --card-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            color: var(--text);
            background-color: var(--primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background-image: url('https://hebbkx1anhila5yf.public.blob.vercel-storage.com/8deec70cff780fe56d1365915016af45.jpg-1K2yWu0WJBCrXiVKaZir4S7Ip9qSgq.jpeg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: -1;
        }

        .app-container {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: white;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            letter-spacing: 1px;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 1rem;
            max-width: 600px;
            margin: 0 auto;
        }

        .card {
            background: var(--card-bg);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 1px solid var(--card-border);
            margin-bottom: 30px;
        }

        .card-header {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-bottom: 1px solid var(--card-border);
        }

        .card-header h2 {
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-header h2 i {
            color: var(--accent);
        }

        .card-body {
            padding: 25px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .input-group {
            position: relative;
        }

        .input-group i {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--accent);
        }

        select,
        input {
            width: 100%;
            padding: 12px 15px 12px 45px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.2);
            color: var(--text);
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        select:focus,
        input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.3);
        }

        select option {
            background-color: var(--secondary);
            color: var(--text);
        }

        button {
            width: 100%;
            padding: 14px;
            border-radius: 8px;
            border: none;
            background: var(--accent);
            color: white;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        button:hover {
            background: var(--accent-light);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .result-card {
            display: none;
        }

        .result-card.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .result-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .result-header h3 {
            font-size: 1.2rem;
            color: var(--text);
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .result-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid var(--card-border);
        }

        .result-item .label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .result-item .value {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .visibility-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.2);
        }

        .visibility-indicator.impossible {
            border-left: 4px solid var(--danger);
        }

        .visibility-indicator.difficult {
            border-left: 4px solid var(--warning);
        }

        .visibility-indicator.possible {
            border-left: 4px solid var(--accent);
        }

        .visibility-indicator.likely {
            border-left: 4px solid var(--success);
        }

        .visibility-text {
            flex: 1;
        }

        .visibility-text h4 {
            margin-bottom: 5px;
        }

        .visibility-text p {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .loader {
            display: none;
            width: 48px;
            height: 48px;
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .footer {
            text-align: center;
            margin-top: 30px;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .result-grid {
                grid-template-columns: 1fr;
            }

            .card-body {
                padding: 20px;
            }
        }

        /* Dark mode toggle */
        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--card-border);
            color: var(--text);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            background: rgba(0, 0, 0, 0.5);
        }
    </style>
</head>

<body>
    <div class="app-container">
        <div class="header">
            <h1><i class="fas fa-moon"></i> Lunar Vision</h1>
            <p>Predict moon sighting visibility with precision astronomical calculations</p>
        </div>

        <div class="card">
            <div class="card-header">
                <h2><i class="fas fa-search"></i> Moon Sighting Predictor</h2>
            </div>
            <div class="card-body">
                <div class="form-group">
                    <label for="country">Select Location</label>
                    <div class="input-group">
                        <i class="fas fa-globe-americas"></i>
                        <select id="country"></select>
                    </div>
                </div>

                <div class="form-row" style="display: flex; gap: 15px;">
                    <div class="form-group" style="flex: 1;">
                        <label for="yearSelect">Year</label>
                        <div class="input-group">
                            <i class="fas fa-calendar-year"></i>
                            <select id="yearSelect" required></select>
                        </div>
                    </div>

                    <div class="form-group" style="flex: 1;">
                        <label for="monthSelect">Month</label>
                        <div class="input-group">
                            <i class="fas fa-calendar-day"></i>
                            <select id="monthSelect" required></select>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="moonSightingDatetime">Sighting Datetime</label>
                    <div class="input-group">
                        <i class="far fa-calendar-alt"></i>
                        <input type="datetime-local" id="moonSightingDatetime">
                    </div>
                </div>

                <button id="predictBtn" onclick="predictMoonSighting()">
                    <i class="fas fa-telescope"></i> Check Moon Visibility
                </button>
            </div>
        </div>

        <div class="loader" id="loader"></div>

        <div class="card result-card" id="resultCard">
            <div class="card-header">
                <h2><i class="fas fa-chart-bar"></i> Visibility Analysis</h2>
            </div>
            <div class="card-body">
                <div id="result"></div>
            </div>
        </div>

        <div class="footer">
            <p>© 2025 Lunar Vision | Astronomical Calculations & Moon Sighting Predictions</p>
        </div>
    </div>

    <script>
        // Function to set the current datetime in the input field
        function setCurrentDatetime() {
            const now = new Date();
            // Format the date as 'YYYY-MM-DDTHH:MM'
            const formattedDate = now.toISOString().slice(0, 16); // Slice to get the 'YYYY-MM-DDTHH:MM' format
            document.getElementById('moonSightingDatetime').value = formattedDate;
        }

        // Country to country code map (You can add more as needed)
        const countryCodes = {
            "za": "South Africa",
            "au": "Australia",
            "sa": "Saudi Arabia",
            "pk": "Pakistan",
            "my": "Malaysia",
            "us": "USA",
            "ae": "United Arab Emirates",
            "eg": "Egypt",
            "in": "India",
            "ng": "Nigeria",
            "sg": "Singapore",
            "fr": "France",
            "de": "Germany",
            "gb": "United Kingdom",
            "br": "Brazil",
            "ca": "Canada",
            "id": "Indonesia",
            "ir": "Iran",
            "tr": "Turkey",
            "iq": "Iraq",
            "sy": "Syria",
            "pk": "Pakistan",
            "dz": "Algeria",
            "ma": "Morocco",
            "bd": "Bangladesh",
            "ke": "Kenya",
            "jo": "Jordan",
            "tn": "Tunisia",
            "ly": "Libya",
            "ps": "Palestine",
            "lk": "Sri Lanka",
            "uz": "Uzbekistan",
            "ye": "Yemen",
            "af": "Afghanistan",
            "mm": "Myanmar",
            "kh": "Cambodia",
            "mn": "Mongolia",
            "bh": "Bahrain",
            "qa": "Qatar",
            "om": "Oman",
            "kw": "Kuwait",
            "lv": "Latvia",
            "ch": "Switzerland",
            "cz": "Czech Republic",
            "es": "Spain",
            "it": "Italy",
            "fi": "Finland",
            "nl": "Netherlands",
            "se": "Sweden",
            "dk": "Denmark",
            "be": "Belgium",
            "at": "Austria",
            "pt": "Portugal",
            "gr": "Greece",
            "ru": "Russia",
            "bg": "Bulgaria",
            "mx": "Mexico",
            "ph": "Philippines",
            "th": "Thailand",
            "ba": "Bosnia and Herzegovina",
            "xk": "Kosovo",
            "al": "Albania",
            "et": "Ethiopia",
            "so": "Somalia",
            "tz": "Tanzania",
            "mr": "Mauritania",
            "mw": "Malawi",
            "sn": "Senegal",
            "gm": "Gambia",
            "ml": "Mali",
            "ne": "Niger",
            "sd": "Sudan",
            "tj": "Tajikistan",
            "kg": "Kyrgyzstan",
            "kz": "Kazakhstan",
            "tm": "Turkmenistan",
            "lb": "Lebanon",
            "az": "Azerbaijan",
            "am": "Armenia"
        };

        // Dynamically generate options for the country select dropdown
        const countrySelect = document.getElementById('country');
        for (const code in countryCodes) {
            const option = document.createElement('option');
            option.value = code;
            option.textContent = countryCodes[code];
            countrySelect.appendChild(option);
        }

        // Populate year dropdown with past 5 years, current year, and future 5 years
        const yearSelect = document.getElementById('yearSelect');
        const currentYear = new Date().getFullYear();
        for (let year = currentYear - 5; year <= currentYear + 5; year++) {
            const option = document.createElement('option');
            option.value = year;
            option.textContent = year;
            if (year === currentYear) {
                option.selected = true;
            }
            yearSelect.appendChild(option);
        }

        // Populate month dropdown
        const monthSelect = document.getElementById('monthSelect');
        const months = [
            { value: 1, name: 'January' },
            { value: 2, name: 'February' },
            { value: 3, name: 'March' },
            { value: 4, name: 'April' },
            { value: 5, name: 'May' },
            { value: 6, name: 'June' },
            { value: 7, name: 'July' },
            { value: 8, name: 'August' },
            { value: 9, name: 'September' },
            { value: 10, name: 'October' },
            { value: 11, name: 'November' },
            { value: 12, name: 'December' }
        ];

        const currentMonth = new Date().getMonth() + 1; // JavaScript months are 0-indexed
        months.forEach(month => {
            const option = document.createElement('option');
            option.value = month.value;
            option.textContent = month.name;
            if (month.value === currentMonth) {
                option.selected = true;
            }
            monthSelect.appendChild(option);
        });

        // Add event listeners to update the datetime input when year or month changes
        yearSelect.addEventListener('change', updateDatetimeConstraints);
        monthSelect.addEventListener('change', updateDatetimeConstraints);

        // Function to update the datetime input constraints based on selected year and month
        function updateDatetimeConstraints() {
            const selectedYear = parseInt(yearSelect.value, 10);
            const selectedMonth = parseInt(monthSelect.value, 10);

            // Create date objects for the first and last day of the selected month
            const firstDay = new Date(selectedYear, selectedMonth - 1, 1);
            const lastDay = new Date(selectedYear, selectedMonth, 0); // Correct last day of the month

            // Adjust for local timezone offset to prevent UTC conversion issues
            const firstDayLocal = new Date(firstDay.getTime() - firstDay.getTimezoneOffset() * 60000);
            const lastDayLocal = new Date(lastDay.getTime() - lastDay.getTimezoneOffset() * 60000);

            // Format dates for the datetime-local input (YYYY-MM-DDTHH:mm)
            const minDate = firstDayLocal.toISOString().slice(0, 16);
            const maxDate = lastDayLocal.toISOString().slice(0, 10) + "T23:59"; // Ensures full last day is selectable

            const datetimeInput = document.getElementById('moonSightingDatetime');
            datetimeInput.min = minDate;
            datetimeInput.max = maxDate;

            // If the current value is outside the new range, reset it
            const currentValue = datetimeInput.value;
            if (currentValue && (currentValue < minDate || currentValue > maxDate)) {
                datetimeInput.value = '';
            }
        }

        // Initialize datetime constraints
        updateDatetimeConstraints();

        async function getWeatherData(lat, lon, sightingDate) {
            try {
                const response = await fetch(`https://api.met.no/weatherapi/locationforecast/2.0/compact?lat=${lat}&lon=${lon}`, {
                    headers: { "User-Agent": "MoonSightingApp/1.0" }
                });
                const data = await response.json();

                const timeseries = data.properties.timeseries;
                if (!timeseries || timeseries.length === 0) return null;

                // Convert sightingDate to UTC string format
                const sightingTimeUTC = new Date(sightingDate).toISOString();

                // Find the closest available weather data point within 24 hours
                let closestWeather = timeseries.reduce((prev, curr) => {
                    let currTime = new Date(curr.time);
                    let prevTime = new Date(prev.time);
                    let sightingTime = new Date(sightingTimeUTC);

                    let currDiff = Math.abs(currTime - sightingTime);
                    let prevDiff = Math.abs(prevTime - sightingTime);

                    // Ensure the closest is within 24 hours
                    return (currDiff < prevDiff && currDiff <= 24 * 60 * 60 * 1000) ? curr : prev;
                });

                // Check if the closest weather data is within 24 hours, otherwise return null
                if (Math.abs(new Date(closestWeather.time) - new Date(sightingTimeUTC)) > 24 * 60 * 60 * 1000) {
                    return null;
                }

                return closestWeather?.data?.instant?.details?.cloud_area_fraction ?? null;
            } catch (error) {
                console.error("Weather API error:", error);
                return null;
            }
        }

        async function getSunsetTime(date = new Date().toISOString().split('T')[0], lat, lon) {
            try {
                const response = await fetch(`https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lon}&date=${date}&formatted=0`);
                const data = await response.json();

                if (data.status === "OK") {
                    const sunsetUtc = new Date(data.results.sunset);
                    return sunsetUtc;
                } else {
                    console.error("Error fetching sunset time:", data.status);
                    return null;
                }
            } catch (error) {
                console.error("Fetch error:", error);
                return null;
            }
        }

        // Function to get the user's current location (coordinates)
        function getUserLocation() {
            return new Promise((resolve, reject) => {
                if ("geolocation" in navigator) {
                    // Request the user's current position
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            // Successfully got the user's position
                            const { latitude, longitude } = position.coords;
                            resolve({ lat: latitude, lon: longitude });
                        },
                        (error) => {
                            // If there's an error (e.g., user denies location access)
                            reject("Error getting location: " + error.message);
                        }
                    );
                } else {
                    reject("Geolocation is not supported by this browser.");
                }
            });
        }

        // Helper function to convert month name to number
        function getMonthNumber(monthName) {
            const months = {
                'January': 1, 'February': 2, 'March': 3, 'April': 4, 'May': 5, 'June': 6,
                'July': 7, 'August': 8, 'September': 9, 'October': 10, 'November': 11, 'December': 12,
                'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,
                'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12
            };
            return months[monthName] || 0;
        }

        async function predictMoonSighting() {
            const countryCode = document.getElementById('country').value;
            const selectedYear = document.getElementById('yearSelect').value;
            const selectedMonth = parseInt(document.getElementById('monthSelect').value);
            const resultDiv = document.getElementById('result');
            const sightingDatetime = document.getElementById('moonSightingDatetime').value;
            const loader = document.getElementById('loader');
            const resultCard = document.getElementById('resultCard');

            // Show loader, hide results
            loader.style.display = 'block';
            resultCard.classList.remove('active');

            // Fetch the moon data for the selected country and year
            try {
                const response = await fetch(`https://gh-pages-cors.haffejeeyoosuf1.workers.dev/?https://calendar-yearly.com/moon/${countryCode.toLowerCase()}/${selectedYear}`);
                const html = await response.text();

                // Parse the HTML response and extract the required details
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                // Get the timezone by looking for divs with the class 'w-1/3 text-gray-600 font-bold text-right pr-4 dark:text-gray-300' and then grabbing the next div
                const timezoneElements = doc.querySelectorAll('.text-gray-600.font-bold.text-right.pr-4');
                const timezoneElement = timezoneElements[5] ? timezoneElements[5].nextElementSibling : null; // Get the 6th div's next sibling (timezone value)

                const timezone = timezoneElement.textContent.trim();

                // Find the new moon date for the selected month
                let newMoonDate = null;
                let newMoonElement = null;

                // First try to find new moon in the table rows
                const tableRows = doc.querySelectorAll('tr');
                for (const row of tableRows) {
                    // Check if this row contains "New Moon" text or title
                    if (row.textContent.includes('New Moon') || row.innerHTML.includes('title="New Moon"')) {
                        const phaseCell = row.querySelector('td:first-child');
                        const dateCell = row.querySelector('td:nth-child(2)');
                        const timeCell = row.querySelector('td:nth-child(3)');

                        if (dateCell && timeCell) {
                            const dateText = dateCell.textContent.trim();
                            const timeText = timeCell.textContent.trim();

                            // Extract month from the date text (format: "January 29, 2025")
                            const dateParts = dateText.split(' ');
                            if (dateParts.length >= 3) {
                                const monthName = dateParts[0];
                                const rowMonth = getMonthNumber(monthName);

                                // If this row is for the selected month
                                if (rowMonth === selectedMonth) {
                                    // Combine date and time for parsing
                                    const fullDateString = `${dateText} ${timeText}`;
                                    newMoonDate = parseDate(fullDateString, timezone, selectedYear);
                                    newMoonElement = { textContent: fullDateString };
                                    break;
                                }
                            }
                        }
                    }
                }

                // If not found in table, try the alternative method
                if (!newMoonElement) {
                    const newMoonElements = doc.querySelectorAll('.px-7.pt-1.font-semibold');
                    // Find the element that corresponds to the selected month
                    for (let i = 0; i < newMoonElements.length; i++) {
                        const element = newMoonElements[i];
                        const text = element.textContent.trim();
                        if (text.includes(months.find(m => m.value === selectedMonth).name)) {
                            newMoonElement = element;
                            break;
                        }
                    }

                    // If still not found, use the third element as a fallback
                    if (!newMoonElement && newMoonElements.length >= 3) {
                        newMoonElement = newMoonElements[2];
                    }
                }

                if (!newMoonElement || !timezoneElement) {
                    resultDiv.innerHTML = `
                        <div class="visibility-indicator impossible">
                            <i class="fas fa-exclamation-circle"></i>
                            <div class="visibility-text">
                                <h4>Error</h4>
                                <p>Unable to find new moon data for ${months.find(m => m.value === selectedMonth).name} ${selectedYear}. Please try another month.</p>
                            </div>
                        </div>
                    `;
                    loader.style.display = 'none';
                    resultCard.classList.add('active');
                    return;
                }

                const { lat, lon } = await getUserLocation();

                // Extract the new moon date
                const newMoonDateString = newMoonElement.textContent.trim();

                // Convert the new moon date to Date object
                newMoonDate = parseDate(newMoonDateString, timezone, selectedYear);
                let sightingDate = sightingDatetime ? new Date(sightingDatetime) : null;
                let sunsetTime = null;

                if (!sightingDate) {
                    // If no sighting date provided, use sunset time on new moon day
                    let formattedNewMoonDate = newMoonDate.toISOString().split('T')[0];
                    sunsetTime = await getSunsetTime(formattedNewMoonDate, lat, lon);
                    sightingDate = sunsetTime;

                    const offset = sightingDate.getTimezoneOffset() * 60000; // Offset in milliseconds
                    const localDate = new Date(sightingDate - offset).toISOString().slice(0, 16);
                    document.getElementById('moonSightingDatetime').value = localDate;
                }

                // Calculate visibility for the new moon date at sunset (for lunar month start date)
                // First get sunset time on new moon day
                const newMoonSunset = sunsetTime;

                // Get moon phase data for new moon sunset
                const newMoonEpochTime = Math.floor(new Date(newMoonSunset).getTime() / 1000);
                const newMoonApiUrl = `https://gh-pages-cors.haffejeeyoosuf1.workers.dev/?https://api.farmsense.net/v1/moonphases/?d=${newMoonEpochTime}`;
                const newMoonApiResponse = await fetch(newMoonApiUrl);
                const newMoonData = await newMoonApiResponse.json();

                let newMoonProbabilityPercentage = 0;

                if (newMoonData.length > 0 && !newMoonData[0].Error) {
                    const newMoonInfo = newMoonData[0];
                    const newMoonIllumination = newMoonInfo.Illumination * 100;
                    const newMoonAngularDiameter = newMoonInfo.AngularDiameter;
                    const newMoonAgeHours = (newMoonSunset - newMoonDate) / (1000 * 60 * 60);

                    calculateFinalProbability(newMoonAgeHours, newMoonIllumination, newMoonAngularDiameter);
                    newMoonProbabilityPercentage = finalProbability;
                }

                const epochTime = Math.floor(new Date(sightingDate).getTime() / 1000);

                let moonData = newMoonData;
                if (newMoonEpochTime != epochTime)
                {
                    // Call the Farmsense API for moon phase data
                    const apiUrl = `https://gh-pages-cors.haffejeeyoosuf1.workers.dev/?https://api.farmsense.net/v1/moonphases/?d=${epochTime}`;
                    const apiResponse = await fetch(apiUrl);
                    moonData = await apiResponse.json();
                }
                
                if (moonData.length === 0 || moonData[0].Error) {
                    resultDiv.innerHTML = `
                        <div class="visibility-indicator impossible">
                            <i class="fas fa-exclamation-circle"></i>
                            <div class="visibility-text">
                                <h4>Error</h4>
                                <p>Error fetching moon phase data. Please try again.</p>
                            </div>
                        </div>
                    `;
                    loader.style.display = 'none';
                    resultCard.classList.add('active');
                    return;
                }

                let cloudCover = null; // Declare cloudCover

                // Get the current year and month
                const currentYear = new Date().getFullYear();
                const currentMonth = new Date().getMonth(); // 0-based (Jan = 0, Dec = 11)

                // Extract year and month from sightingDate
                const sightingYear = new Date(sightingDate).getFullYear();
                const sightingMonth = new Date(sightingDate).getMonth();

                // Check if sightingDate is within the current year and month
                if (sightingYear === currentYear && sightingMonth === currentMonth) {
                    // Get weather data (cloud cover %)
                    cloudCover = await getWeatherData(lat, lon, sightingDate);
                }

                // Get moon data
                const moonInfo = moonData[0];

                // Convert moon age from days to hours
                const moonAge = (newMoonDate - sightingDate) / (1000 * 60 * 60); // Convert ms to hours

                // Convert illumination to percentage
                const illumination = moonInfo.Illumination * 100;

                // Use Angular Diameter as a secondary indicator (larger moons are easier to see)
                const angularDiameter = moonInfo.AngularDiameter;

                // Calculate visibility for the sighting date (for display purposes)
                const sightingProbability = calculateFinalProbability(moonAge, illumination, angularDiameter);
                const sightingProbabilityPercentage = finalProbability;

                // Adjust for cloud cover if provided.
                let cloudMessage = "";
                let cloudAdjustedProbability = finalProbability;

                if (cloudCover !== null) {
                    if (cloudCover > 80) {
                        cloudAdjustedProbability = Math.max(finalProbability - 50, 0);
                        cloudMessage = `Unlikely in your area (~${Math.round(cloudAdjustedProbability)}%) - Cloudy Sky`;
                    } else if (cloudCover > 50) {
                        // For partly cloudy skies, reduce the final probability by 10%
                        cloudAdjustedProbability = Math.max(finalProbability - 15, 0);
                        cloudMessage = `(~${Math.round(cloudAdjustedProbability)}%) - Partly Cloudy`;
                    }
                    else if (cloudCover > 25) {
                        cloudAdjustedProbability = Math.max(finalProbability - 5, 0);
                        cloudMessage = `(~${Math.round(cloudAdjustedProbability)}%) - Mostly Clear`;
                    }
                    else {
                        cloudMessage = `(~${Math.round(cloudAdjustedProbability)}%) - Clear Skies`;
                    }
                }

                const options = {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    timeZoneName: 'long'
                };

                const dateOnlyOptions = {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    timeZoneName: 'long' // Keeps the timezone but removes the time
                };

                var newMoonNextDayDate = new Date(newMoonDate.getTime() + 86400000);

                // Determine the likely start date of the new lunar month based on new moon visibility
                const likelyStartDate = newMoonProbabilityPercentage > 50 ?
                    newMoonDate.toLocaleDateString("en-US", dateOnlyOptions) :
                    newMoonNextDayDate.toLocaleDateString("en-US", dateOnlyOptions);

                // Determine visibility class for styling
                let visibilityClass = "impossible";
                let visibilityIcon = "fa-times-circle";

                if (finalProbability >= 80) {
                    visibilityClass = "likely";
                    visibilityIcon = "fa-check-circle";
                } else if (finalProbability >= 60) {
                    visibilityClass = "likely";
                    visibilityIcon = "fa-check";
                } else if (finalProbability >= 40) {
                    visibilityClass = "possible";
                    visibilityIcon = "fa-question-circle";
                } else if (finalProbability >= 20) {
                    visibilityClass = "difficult";
                    visibilityIcon = "fa-exclamation-triangle";
                }

                // Display results
                resultDiv.innerHTML = `
            <div class="result-header">
                <h3>Moon Visibility Analysis</h3>
            </div>
            
            <div class="result-grid">
                <div class="result-item">
                    <div class="label"><i class="fas fa-calendar-day"></i> New Moon Born</div>
                    <div class="value">${newMoonDate.toLocaleDateString("en-US", options)}</div>
                </div>
                
                <div class="result-item">
                    <div class="label"><i class="fas fa-hourglass-half"></i> Moon Age</div>
                    <div class="value">${moonAge.toFixed(2)} hours</div>
                </div>
                
                <div class="result-item">
                    <div class="label"><i class="fas fa-adjust"></i> Illumination</div>
                    <div class="value">${illumination.toFixed(1)}%</div>
                </div>
                
                <div class="result-item">
                    <div class="label"><i class="fas fa-ruler-combined"></i> Angular Diameter</div>
                    <div class="value">${angularDiameter.toFixed(2)}°</div>
                </div>
                
                ${cloudCover !== null ? `
                <div class="result-item">
                    <div class="label"><i class="fas fa-cloud"></i> Cloud Cover</div>
                    <div class="value">${cloudCover.toFixed(1)}%</div>
                </div>
                ` : ''}
            </div>
            
            <div class="visibility-indicator ${visibilityClass}">
                <i class="fas ${visibilityIcon}"></i>
                <div class="visibility-text">
                    <h4>Estimated Visibility: ${sightingProbability}</h4>
                    ${cloudCover !== null ? `<p>Local Conditions: ${cloudMessage}</p>` : ''}
                </div>
            </div>
            
            <div class="visibility-indicator likely" style="margin-top: 15px;">
                <i class="fas fa-calendar-check"></i>
                <div class="visibility-text">
                    <h4>New Lunar Month Start Date</h4>
                    <p>${likelyStartDate} (After Sunset)</p>
                    <p>${new Date(newMoonNextDayDate.getTime() + 86400000).toLocaleDateString("en-US", dateOnlyOptions)} (First Day)</p>
                </div>
            </div>
        `;

                // Hide loader, show results
                loader.style.display = 'none';
                resultCard.classList.add('active');

            } catch (error) {
                resultDiv.innerHTML = `
            <div class="visibility-indicator impossible">
                <i class="fas fa-exclamation-circle"></i>
                <div class="visibility-text">
                    <h4>Error</h4>
                    <p>Error fetching data. Please try again. ${error}</p>
                </div>
            </div>
        `;
                console.error(error);
                loader.style.display = 'none';
                resultCard.classList.add('active');
            }
        }

        // Helper function to convert a formatted string into a valid date
        function parseDate(dateString, timezone, defaultYear = new Date().getFullYear()) {
            const months = {
                'January': '01', 'February': '02', 'March': '03', 'April': '04', 'May': '05', 'June': '06',
                'July': '07', 'August': '08', 'September': '09', 'October': '10', 'November': '11', 'December': '12',
                'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04', 'May': '05', 'Jun': '06',
                'Jul': '07', 'Aug': '08', 'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12'
            };

            // Combined regex for both date formats
            const regex = /(?:(\d{1,2}) ([A-Za-z]+) (\d{1,2}):(\d{2}))|(?:([A-Za-z]+) (\d{1,2}), (\d{4}) (\d{1,2}):(\d{2}) (AM|PM))/;
            const match = dateString.match(regex);

            let year, month, day, hour, minute;

            if (match) {
                if (match[1]) {
                    // Format: "29 Mar 12:58"
                    day = match[1].padStart(2, '0');
                    month = months[match[2]];
                    year = defaultYear; // Use provided default year
                    hour = match[3].padStart(2, '0');
                    minute = match[4];
                } else {
                    // Format: "March 29, 2024 12:58 PM"
                    month = months[match[5]];
                    day = match[6].padStart(2, '0');
                    year = match[7];
                    hour = parseInt(match[8]);
                    minute = match[9];

                    // Convert 12-hour format to 24-hour format
                    if (match[10] === 'PM' && hour < 12) hour += 12;
                    if (match[10] === 'AM' && hour === 12) hour = 0;
                    hour = hour.toString().padStart(2, '0');
                }
            } else {
                // No match found, return today's date
                const now = new Date();
                year = defaultYear;
                month = (now.getMonth() + 1).toString().padStart(2, '0');
                day = now.getDate().toString().padStart(2, '0');
                hour = now.getHours().toString().padStart(2, '0');
                minute = now.getMinutes().toString().padStart(2, '0');
            }

            // Format as 'YYYY-MM-DDTHH:MM:SS'
            const formattedDate = `${year}-${month}-${day}T${hour}:${minute}:00`;

            // Create a UTC Date object
            const date = new Date(formattedDate);

            // Adjust for the given timezone
            const formattedDateWithTimezone = new Date(date.toLocaleString("en-US", { timeZone: timezone }));

            return formattedDateWithTimezone;
        }

        // Calculate probability for moonAge with custom thresholds and linear interpolation
        function calcMoonAgeProbability(moonAge) {
            let probability, message;
            if (moonAge <= 12) {
                probability = 5;
                message = `Impossible (~${probability}%) - Too Young`;
            } else if (moonAge <= 15) {
                // Interpolate from 5% at 12 hrs to 25% at 15 hrs
                probability = 5 + ((moonAge - 12) / (15 - 12)) * (25 - 5);
                message = `Extremely Difficult (~${Math.round(probability)}%)`;
            } else if (moonAge < 18) {
                // Interpolate from 25% at 15 hrs to 50% at 18 hrs
                probability = 25 + ((moonAge - 15) / (18 - 15)) * (50 - 25);
                message = `Possible (~${Math.round(probability)}%)`;
            } else if (moonAge <= 24) {
                // Interpolate from 50% at 18 hrs to 70% at 24 hrs
                probability = 50 + ((moonAge - 18) / (24 - 18)) * (70 - 50);
                message = `Likely (~${Math.round(probability)}%)`;
            } else {
                probability = 90;
                message = `Easily Visible (~${probability}%)`;
            }
            return { probability, message };
        }

        // Calculate probability for illumination with custom thresholds (example values)
        function calcIlluminationProbability(illumination) {
            let probability, message;
            if (illumination <= 1) {
                probability = 5;
                message = `Impossible (~${probability}%)`;
            } else if (illumination <= 2) {
                // Interpolate from 5% to 20%
                probability = 5 + ((illumination - 1) / (2 - 1)) * (20 - 5);
                message = `Difficult (~${Math.round(probability)}%)`;
            } else if (illumination <= 3) {
                // Interpolate from 20% to 50%
                probability = 20 + ((illumination - 2) / (3 - 2)) * (50 - 20);
                message = `Possible (~${Math.round(probability)}%)`;
            } else if (illumination < 5) {
                // Interpolate from 50% to 70%
                probability = 50 + ((illumination - 3) / (5 - 3)) * (70 - 50);
                message = `Likely (~${Math.round(probability)}%)`;
            } else if (illumination <= 7) {
                // Interpolate from 70% to 90%
                probability = 70 + ((illumination - 5) / (7 - 5)) * (90 - 70);
                message = `Very Likely (~${Math.round(probability)}%)`;
            } else {
                probability = 90;
                message = `Easily Visible (~${probability}%)`;
            }
            return { probability, message };
        }

        // Calculate probability for angularDiameter with custom thresholds (example values)
        function calcAngularDiameterProbability(angularDiameter) {
            let probability, message;
            if (angularDiameter < 0.5) {
                probability = 5;
                message = `Impossible (~${probability}%)`;
            } else if (angularDiameter <= 0.52) {
                // Interpolate from 5% to 25%
                probability = 5 + ((angularDiameter - 0.5) / (0.52 - 0.5)) * (25 - 5);
                message = `Extremely Difficult (~${Math.round(probability)}%)`;
            } else if (angularDiameter < 0.53) {
                // Interpolate from 25% to 50%
                probability = 25 + ((angularDiameter - 0.52) / (0.53 - 0.52)) * (50 - 25);
                message = `Possible (~${Math.round(probability)}%)`;
            } else if (angularDiameter <= 0.55) {
                // Interpolate from 50% to 70%
                probability = 50 + ((angularDiameter - 0.53) / (0.55 - 0.53)) * (70 - 50);
                message = `Likely (~${Math.round(probability)}%)`;
            } else {
                probability = 90;
                message = `Easily Visible (~${probability}%)`;
            }
            return { probability, message };
        }

        let finalProbability = 0;
        // Combine the probabilities from all three parameters into a final probability.
        // Here we simply average the three probabilities. You could adjust this with weights if desired.
        function calculateFinalProbability(moonAge, illumination, angularDiameter) {
            const moon = calcMoonAgeProbability(moonAge);
            const illum = calcIlluminationProbability(illumination);
            const angDia = calcAngularDiameterProbability(angularDiameter);

            // Simple average of the three probabilities.
            finalProbability = (moon.probability + illum.probability + angDia.probability) / 3;

            // Choose a final message based on the final probability value.
            let finalMessage;
            if (finalProbability < 20) {
                finalMessage = `Impossible (~${Math.round(finalProbability)}%)`;
            } else if (finalProbability < 40) {
                finalMessage = `Extremely Difficult (~${Math.round(finalProbability)}%)`;
            } else if (finalProbability < 60) {
                finalMessage = `Possible (~${Math.round(finalProbability)}%)`;
            } else if (finalProbability < 80) {
                finalMessage = `Likely (~${Math.round(finalProbability)}%)`;
            } else {
                finalMessage = `Easily Visible (~${Math.round(finalProbability)}%)`;
            }

            return finalMessage;
        }
    </script>

</body>

</html>